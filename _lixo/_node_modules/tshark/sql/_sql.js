/**
 * Driver para conexões a datasources baseados em SQL.
 * @author labs
 * @since 10/03/2016
 * @constructor
 */
function SQL(db){
    this.db = db;
}

//region :: Includes

const util      = require('util')
    , _         = require('underscore')
    , moment    = require('moment')
    , log       = require('../_log')
;

//endregion


/**
 * Inicializa o driver
 * @param connParams
 */
SQL.prototype.init = function(connParams){

    // Parametros de conexão
    this.connParams = connParams;

    /**
     * Armazena estrutura extraida do provider
     * @type {{
     *      table   : '',
     *      alias   : '',
     *      distinct: '',
     *      fields  : [],
     *      joins   : [],
     *      meta    : {},
     *      key     : {field: '', val: ''},
     *      where   : [],
     *      group   : [],
     *      having  : [],
     *      order   : [],
     *      limit   : {max: 0, page: 0},
     *      showSQL : false
     * }}
     */
    this.sqlParams = {};

};


// region :: Utils

/**
 * Verifica se o texto é uma data válida
 * @param str {string}
 * @returns {boolean}
 */
function isDate(str){
    if (!str) return false;
    var sep = (str.indexOf('/') > -1
            ? '/'
            : str.indexOf('-') > -1
            ? '-'
            : ''
    );
    if (!sep) return false;

    var tmp = str.split(sep);
    if (tmp.length != 3) return false;

    if (!util.isNumber(tmp[0]) ||
        !util.isNumber(tmp[1]) ||
        !util.isNumber(tmp[2])) return false;

    return true;
}

//endregion


//region :: Parsing


/**
 * Processa um provider e o transforma em sqlParams
 * @param provider
 * @param obj { BizObject }
 */
SQL.prototype._parseProvider = function(provider, obj){

    // Ajusta sqlParams
    this.sqlParams = {
        key     : {field: '', val: ''},
        fields  : provider['fields'] || {},
        meta    : {},
        joins   : [],
        where   : provider['where']  || [],
        search  : provider['search'] || [],
        group   : provider['group']  || [],
        having  : provider['having'] || [],
        order   : provider['order']  || [],
        limit   : {max: provider['limit'] || 0, page: 0},
        showSQL : provider['showSQL'] || false
    };

    var fields = (obj.params['fields'] || []).concat(obj.params['_fields'] || []);

    // Processa provider
    for(var s in provider.sources) {
        var source = provider.sources[s].src
            , alias = 'tb' + s;

        // Tabela principal
        if (!this.sqlParams['table']) {
            this.sqlParams.table = source.table;
            this.sqlParams.key.field = source.metadata.key;
            this.sqlParams.key.val = obj.params[source.metadata.key];
            this.sqlParams.alias = alias;
            this.sqlParams.distinct = provider.sources[s]['distinct'];
        }

        // Fields
        this.db.parseFields(provider.sources[s], fields, source.metadata.fields, alias);

        // Joins
        if (provider.sources[s]['join']) {
            this.db.parseJoin(provider.sources[s]['join'], source.table, alias, '');
        }
    }
    
};


/**
 * Ajusta fields em sqlParams
 * @param prov
 * @param ctx_fields
 * @param meta_fields
 * @param alias
 */
SQL.prototype._parseFields = function(prov, ctx_fields, meta_fields, alias){

    // Fields forçados
    if (prov['force_fields'] && util.isArray(prov['force_fields'])){
        prov['force_fields'].forEach(function(f){
            if (!this.sqlParams.fields[f]) {
                this.sqlParams.fields[f] = alias;
            }
        }, this);

        // Fields mapeados
    } else {
        for (var f in meta_fields){

            // Primeiro a chegar entra
            if (!this.sqlParams.fields[f]) {
                var ok = false;

                // Acrescenta _key
                if (f.substr(-4) == '_key') {
                    ok = true;
                }

                // Select all em fields
                if (prov['fields'] && (prov['fields'] == '*' || prov['fields'][0] == '*')) {
                    ok = true;
                }

                // Explicitamente requisitado
                if (prov['fields'] && prov['fields'].indexOf(f) > -1) {
                    ok = true;
                    prov['fields'][prov['fields'].indexOf(f)] = null;
                }

                // Em contexto
                if (ctx_fields.indexOf(f) > -1){
                    ok = true;
                }

                if (ok) {
                    this.sqlParams.fields[f] = alias;
                    this.sqlParams.meta[f] = meta_fields[f];
                }
            }
        }
    }

    // Fields de função
    if (prov['fields'] && util.isArray(prov['fields'])) {
        prov['fields'].forEach(function (f) {
            if (f && util.isArray(f)) {
                var 
                    fld    = f[0]
                    , tipo = f[1]
                    , fnc  = f[2];
                
                if (!this.sqlParams.fields['__as__']) {
                    this.sqlParams.fields['__as__'] = [];
                }
                
                if (tipo == 'as') {
                    this.sqlParams.fields['__as__'].push(
                        alias + '.' + fld + ' as ' + fnc
                    );
                
                } else if (tipo == 'func'){
                    this.sqlParams.fields['__as__'].push(
                        '(' + fnc + ') as ' + fld
                    );
                }
            }
            
        }, this);
    }

};


/**
 * Identifica os joins
 * @param join { {source: 0, tipo: 'inner', on: 'map_filiais_key', where: ''} }
 * @param table
 * @param alias
 * @param nolock
 */
SQL.prototype._parseJoin = function(join, table, alias, nolock){

    // Join implicito
    if (join['tipo'] == 'implicit') {
        this.sqlParams.joins.push(", " + table + " as " + alias + ' ' + nolock);

    // Join 'à mão'
    } else if (join['tipo'] == 'sql'){
        this.sqlParams.joins.push(join['sql']);

    // Join normal
    } else {
        var template = " %s JOIN %s %s ON (%s %s %s ";
        /*if (join['where']) {
         var wtempl = " %s tb%s.%s %s '%s' ";
         var jwhere = parseWhereItem(join['where'], $params['master']['dataset']);
         foreach ($jwhere as $w){
         //array($tbRef, $key, $cond, '=', $where_key);
         if (is_string($w)) {
         $template .= $w;
         } else {
         if ($w[4] == 'NULL') {
         $wtempl = " %s tb%s.%s %s %s ";
         }
         $template .= sprintf($wtempl, $w[0], $w[1], $w[2], $w[3], $w[4]);
         }
         }
         }*/
        template += ")";

        var
            opt             = (join['opt'] ? join['opt'] : '=')
            , that_alias    = "tb" + join['source']
            , this_key
            , that_key
            ;

        // Chaves idênticas em ambas tabelas
        if (!util.isArray(join['on'])){
            this_key = alias + '.' + join['on'];
            that_key = that_alias + '.' + join['on'];

            // Chaves diferentes nas tabelas:
        } else {
            this_key = alias + '.' + join['on'][0];
            that_key = that_alias + '.' + join['on'][1];
        }

        this.sqlParams.joins.push(
            util.format(template,
                join['tipo'], table, alias + ' ' + nolock, this_key, opt, that_key
            )
        );
    }
};


/**
 * Processa where
 * @param params { {} }
 */
SQL.prototype._parseWhere = function(params){

    var sql     = ''
        , templ = ' %s tb%s.%s %s %s ';
    this.sqlParams.where.forEach(function(where){

        // Where digitado
        if (typeof where == 'string'){
            sql += ' ' + where + ' ';

        // Where composto
        } else {

            // ["AND", '0', "map_filiais_key", "check"]
            if (where.length == 4){
                var flag    = where.pop()
                    , val   = params[where[2]]
                ;

                if (val == 'NEW_KEY' || (!val && flag.toUpperCase() == 'GET')){
                    val = -999;
                }

                if (val){
                    where.push('=');
                    where.push("'" + val + "'");

                } else {
                    where = [];
                }
            }

            if (where.length){
                where.unshift(templ);
                sql += util.format.apply(util, where);
            }

        }
    });

    // Retorna
    return sql;
};


/**
 * Processa req.query e alimenta search
 * @param query { string }
 */
SQL.prototype._parseSearch = function(query){
    var sql     = ''
        ,qry    = query.split(' ');

    var glue = ' AND ', maior = false, menor = false;
    this.sqlParams['search'].forEach(function(param){

        switch (param.param.toUpperCase()) {

            case 'LIKE':
                qry.forEach(function (q) {
                    sql += glue + 'tb' + param.alias + '.' + param.field + " LIKE '%" + q + "%'";
                    glue = ' OR ';
                });
                break;

            case 'IN':
                sql += glue + 'tb' + param.alias + '.' + param.field + " IN ('" + qry.join("', '") + "')";
                break;

            case '>':
            case '>=':
                if (!maior) {
                    maior = true;
                    qry.forEach(function (q) {
                        if (util.isNumber(q) || isDate(q)) {
                            sql += glue + 'tb' + param.alias + '.' + param.field + " > '" + q + "'";
                            glue = ' OR ';
                        }
                    });
                }
                break;

            case '<':
            case '<=':
                if (!menor) {
                    menor = true;
                    qry.forEach(function (q) {
                        if (util.isNumber(q) || isDate(q)) {
                            sql += glue + 'tb' + param.alias + '.' + param.field + " < '" + q + "'";
                            glue = ' OR ';
                        }
                    });
                }
                break;

            default:
                qry.forEach(function (q) {
                    sql += glue + 'tb' + param.alias + '.' + param.field + " " + param.param + " '" + q + "'";
                    glue = ' OR ';
                });
                break;
        }
    });

    return sql;
};


//endregion


//region :: CRUD

/**
 * Retorna um pacote no formato padrão
 * @returns {{index: {}, rows: Array, page: number}}
 */
function getDataPack(){
    return {
        index: {},
        rows: [],
        page: 0
    };
}

/**
 * Executa o parsing do provider, e se for um select para insert
 * interrompe o processo enviando um row default para o client.
 * @param provider
 * @param obj { BizObject }
 * @private
 */
SQL.prototype._select = function(provider, obj){
    this.db.parseProvider(provider, obj);

    // Row de insert
    if (this.sqlParams.key.val == 'NEW_KEY'){
        var row = {_key_: 'NEW_KEY'};
        for (var f in this.sqlParams.fields){
            var val     = ''
                , tipo  = this.sqlParams.meta[f]['tipo'] || {}
                , def   = tipo['default']
                , type  = tipo['type']
            ;
            def = (typeof def == 'string'? def.toUpperCase() : def);

            // Monta valores
            switch (type){
                case 'int':
                    val = def || 0;
                    break;

                case 'float':
                case 'money':
                case 'percent':
                    val = def || '0,00';
                    break;

                case 'date':
                    if (def == 'NOW' || def == 'DATE' || def == 'HOJE'){
                        val = moment().format("DD/MM/YYYY");
                    }
                    break;

                case 'time':
                    if (def == 'NOW' || def == 'DATE' || def == 'HOJE'){
                        val = moment().format("HH:mm:ss");
                    }
                    break;

                case 'datetime':
                    if (def == 'NOW' || def == 'DATE' || def == 'HOJE'){
                        val = moment().format("DD/MM/YYYY HH:mm:ss");
                    }
                    break;

                default:
                    val = (def ? def : val);
            }

            row[f] = (val == 'NEW_KEY' ? '' : val);
        }

        // Pacote de retorno
        var data = getDataPack();
        data.rows.push(row);
        
        return data;
    }
    
};


/**
 * Processamento default de resultado de selects
 * @param results
 * @param sql
 */
SQL.prototype._processResults = function(results, obj, sql, meta){
    meta = meta || {};
    var ndx         = {}
        , key       = (this.sqlParams.key
            ? this.sqlParams.key.field
            : meta['key']
                ? meta.key
                : ''
        )
        , onGetRow  = obj['onGetRow']
        , db        = this
        , data      = getDataPack()
    ;

    data.key = key;

    // Processa
    results.forEach((row, i) => {

        // Monta indice
        row._key_ = row[key];
        data.index[row._key_] = i;

        // Em raros casos onde não houver fields pro sql, será forçado um '*', e
        // essa entrada aqui garantirá que todos os fields fiquem em lower
        if (this.sqlParams['force_lower']){
            var k, keys = Object.keys(row);
            var n = keys.length;
            var newobj = {};
            while (n--) {
                k = keys[n];
                newobj[k.toLowerCase()] = row[k];
            }
            row = newobj;
        }

        // Permite ajustar row no business object
        if (onGetRow) {
            onGetRow.call(obj, row);
        }
        data.rows.push(row);
    });

    // Página
    data.page = (this.sqlParams.limit
        ? this.sqlParams.limit.page +1
        : meta['limit'] && meta.limit['page']
            ? meta.limit.page
            : 1
    );

    // ShowSQL
    if (this.sqlParams.showSQL) {
        data['sql'] = sql;
        log.msg('SQL gerado:', sql);
    }

    // Retorna
    return {data: data};
};


//endregion


module.exports = SQL;